// @ts-nocheck
import { useEffect, useState } from "react";
import spotify, { getAllUserPlaylists } from "../util/spotify";
import "./Playlist.scss";
import "missing-native-js-functions";
import { Popup } from "./Popup";

function millisToMinutesAndSeconds(millis: number) {
	var minutes = Math.floor(millis / 60000);
	var seconds = Math.floor((millis % 60000) / 1000);
	return minutes + ":" + (seconds < 10 ? "0" : "") + seconds;
}

export default function Playlist({
	id,
	playlists: pl,
}: {
	id: string;
	playlists: SpotifyApi.PlaylistObjectSimplified[];
}) {
	const [playlist, setPlaylist] = useState<SpotifyApi.SinglePlaylistResponse | null>(null);
	const artists = new Map<string, SpotifyApi.ArtistObjectFull>();
	const [popup, openPopup] = useState(false);
	const [count, setCount] = useState(0);
	const [minimumSizePlaylist, setMinimumSizePlaylist] = useState(30);
	const [genres, setGenres] = useState<string[]>([]);
	const [excludedGenres, setExcludedGenres] = useState<string[]>([]);
	const [onlyTopGenre, setOnlyTopGenre] = useState(false);
	const [progress, setProgress] = useState(false);

	const playlists = [...pl];

	async function handleTracks(items: SpotifyApi.PlaylistTrackObject[]) {
		items = items.filter((x) => !!x.track.id); // filter local songs

		var artistIds = items
			.map((x) => x.track.artists.map((y) => y.id))
			.flat()
			.unique()
			// @ts-ignore
			.filter((x) => x && !artists.has(x.id));

		while (artistIds.length) {
			const batch = artistIds.slice(0, 50);
			artistIds = artistIds.slice(50);

			const { body } = await spotify.getArtists(batch);
			body.artists.forEach((x) => artists.set(x.id, x));
		}

		items.forEach(
			(x) =>
				(x.track.genres = x.track.artists
					.map((y) => artists.get(y.id)?.genres || [])
					.flat()
					.unique())
		);
		return items;
	}

	useEffect(() => {
		console.log("fetch playlist");
		spotify.getPlaylist(id, {}).then(async ({ body: state }) => {
			state.tracks.items = await handleTracks(state.tracks.items);
			setPlaylist(state);

			while (state.tracks.next) {
				console.log("fetch tracks", state.tracks);

				const { body: tracks } = await spotify.getPlaylistTracks(id, {
					offset: state.tracks.offset + state.tracks.limit,
				});

				state.tracks = { ...tracks, items: state.tracks.items.concat(await handleTracks(tracks.items)) };

				setPlaylist({ ...state });
			}
		});
	}, [id]);

	async function convert(doCount = false) {
		if (!playlist) return;
		// spotify
		const genres = playlist.tracks.items
			.map((x) => x.track.genres || [])
			.flat()
			.unique();

		const listGenrePlaylists = [];

		var i = 0;
		const percentage = 100 / count;

		for (const genre of genres) {
			var songs = playlist.tracks.items
				.filter((x) => {
					if (onlyTopGenre) return (x.track.genres || []).first() === genre;
					return (x.track.genres || []).includes(genre);
				})
				.map((x) => x.track.uri);
			if (songs.length < minimumSizePlaylist) continue;
			if (excludedGenres.includes(genre)) {
				listGenrePlaylists.push(genre);
				continue;
			}
			i++;
			listGenrePlaylists.push(genre);

			if (doCount) continue;

			var list = playlists.find((x) => x.name.toLowerCase() === genre.toLowerCase());
			if (!list) {
				list = (await spotify.createPlaylist(genre, { public: false, description: `${genre} autogenerated` }))
					.body;
				playlists.push(list);
			}

			const songPercentage = percentage / (songs.length || 1);
			var j = 1;

			while (songs.length) {
				const batch = songs.slice(0, 100);
				songs = songs.slice(100);
				j += songs.length;

				await spotify.replaceTracksInPlaylist(list.id, batch);
				setProgress(percentage * i * songPercentage * j);
			}

			setProgress(percentage * i);
		}

		setCount(i);
		setGenres(listGenrePlaylists);
	}

	if (!playlist) return <div>Loading playlist ...</div>;

	function toggleGenre(genre) {
		var list = [...excludedGenres];

		if (list.includes(genre)) list = list.filter((x) => x !== genre);
		else list.push(genre);

		setExcludedGenres(list);
	}

	return (
		<div className="playlist">
			{playlist.tracks.items.length !== playlist.tracks.total && (
				<progress max={playlist.tracks.total} value={playlist.tracks.items.length}></progress>
			)}

			<Popup open={popup} setOpen={openPopup}>
				<h1 style={{ fontSize: "3rem" }}>Separate into genres</h1>
				{count ? (
					<p className="yellow">Warning this will generate {count} new genre playlists</p>
				) : (
					<p>
						Sorry but your playlist is too small,
						<br />
						change the minimum size of genre playlist
					</p>
				)}

				<ul className="genres">
					{genres.map((x) => (
						<li
							onClick={toggleGenre.bind(null, x)}
							style={{ textDecoration: excludedGenres.includes(x) ? "line-through" : "" }}
						>
							{x}
						</li>
					))}
				</ul>

				<label>
					<input
						type="number"
						min="1"
						value={minimumSizePlaylist}
						onChange={(e) => setMinimumSizePlaylist(Number(e.target.value))}
					/>
					<br />
					Minimum size of genre playlist
				</label>

				<label>
					<input type="checkbox" value={onlyTopGenre} onChange={(e) => setOnlyTopGenre(e.target.checked)} />
					Only filter by main genre of song
				</label>

				<div>
					<button className="button" style={{ fontSize: "0.6rem" }} onClick={() => convert(true)}>
						Recalculate
					</button>
				</div>

				<div>
					<button className="button dark" onClick={() => convert(false)}>
						Separate
					</button>
				</div>

				<div>{progress >= 100 ? "DONE" : progress && <progress max={100} value={progress}></progress>}</div>
			</Popup>

			<div className="info">
				<div className="art">
					<img src={playlist.images.first()?.url} alt="Playlist cover" />
				</div>

				<div className="meta">
					<div className="author">{playlist.owner.display_name}</div>

					<div className="name">{playlist.name}</div>

					<div className="actions">
						<button onClick={() => openPopup(true) || convert(true)} className="button light save">
							Separate into genres
						</button>
					</div>
				</div>
			</div>

			<div className="tracks">
				<div className="heading">
					<div className="number">#</div>

					<div className="title">Song</div>

					<div className="length">Length</div>
				</div>

				{playlist.tracks.items.map((x, i) => (
					<div className="track" key={x.track.id + i + playlist.id}>
						<div className="number">{i + 1}</div>

						<div className="title">{x.track.name}</div>

						<div className="length">{millisToMinutesAndSeconds(x.track.duration_ms)}</div>
					</div>
				))}
			</div>
		</div>
	);
}
